use std::path::PathBuf;
use std::{collections::BTreeMap, fmt::Display};

use anyhow::{anyhow, bail, Context, Result};
use serde::Deserialize;

#[derive(PartialEq, Eq, Debug)]
/// Represents basic information of a package in a lock file
/// We keep only the name and the version
struct Package {
    name: String,
    version: String,
}

impl Package {
    fn new(name: &str, version: &str) -> Self {
        Self {
            name: name.to_string(),
            version: version.to_string(),
        }
    }
}

impl Display for Package {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}@{}", self.name, self.version)
    }
}

#[derive(Deserialize, Debug)]
struct CargoLock {
    #[serde(rename = "package")]
    packages: Vec<CargoPackage>,
}

impl CargoLock {
    fn packages(self) -> Vec<Package> {
        self.packages.into_iter().map(|p| p.into()).collect()
    }
}

#[derive(Deserialize, Debug)]
struct CargoPackage {
    name: String,
    version: String,
}

impl From<CargoPackage> for Package {
    fn from(cargo_package: CargoPackage) -> Self {
        Package::new(&cargo_package.name, &cargo_package.version)
    }
}

#[derive(Deserialize, Debug, PartialEq, Eq)]
struct NpmLock {
    packages: BTreeMap<String, NpmPackage>,
}

impl NpmLock {
    fn packages(self) -> Vec<Package> {
        self.packages
            .into_iter()
            .filter(|(k, _)| !k.is_empty())
            .map(|(k, v)| Package::new(&k.replace("node_modules/", ""), &v.version))
            .collect()
    }
}

#[derive(Deserialize, Debug, PartialEq, Eq)]
struct NpmPackage {
    version: String,
}

fn parse_lock(name: &str, contents: &str) -> Result<Vec<Package>> {
    let packages = match name {
        "Cargo.lock" | "poetry.lock" => {
            let cargo_lock: CargoLock =
                toml::from_str(contents).context("Could not parse Cargo.lock or poetry.lock")?;
            cargo_lock.packages()
        }
        "package-lock.json" => {
            let npm_lock: NpmLock =
                serde_json::from_str(contents).context("Could not parse package-lock.json")?;
            npm_lock.packages()
        }
        "yarn.lock" => {
            let entries =
                yarn_lock_parser::parse_str(contents).context("Could not parse yarn.lock")?;
            entries
                .iter()
                .map(|e| Package::new(e.name, e.version))
                .collect()
        }
        _ => bail!("Unknown lock name: {name}"),
    };
    Ok(packages)
}

pub fn run() -> Result<()> {
    let args: Vec<_> = std::env::args().collect();
    if args.len() != 2 {
        bail!("Expected exactly one arg");
    }

    let lock_path = &args[1];
    let lock_path = PathBuf::from(lock_path);
    let name = lock_path
        .file_name()
        .ok_or_else(|| anyhow!("Lock path should have a file name"))?;
    let name = name
        .to_str()
        .ok_or_else(|| anyhow!("File name should be valid UTF-8"))?;
    let lock_contents = std::fs::read_to_string(&lock_path).context("Could not read lock file")?;
    let packages = parse_lock(name, &lock_contents)?;
    for package in packages {
        println!("{package}");
    }
    Ok(())
}

#[cfg(test)]
mod tests {

    use super::*;

    #[test]
    fn test_cargo_lock() {
        let contents = r#"
# This file is automatically @generated by Cargo.
version = 3

[[package]]
name = "anyhow"
version = "1.0.58"
source = "registry+https://github.com/rust-lang/crates.io-index"

[[package]]
name = "lockdiff"
version = "1.0.0"
dependencies = [
 "anyhow",
]"#;
        let packages = parse_lock("Cargo.lock", contents).unwrap();
        assert_eq!(
            &packages,
            &[
                Package::new("anyhow", "1.0.58"),
                Package::new("lockdiff", "1.0.0")
            ]
        );
    }

    #[test]
    fn test_poetry_lock() {
        let contents = r#"
[[package]]
name = "arrow"
version = "1.2.2"
python-versions = ">=3.6"

[package.dependencies]
python-dateutil = ">=2.7.0"
"#;
        let packages = parse_lock("poetry.lock", contents).unwrap();
        assert_eq!(&packages, &[Package::new("arrow", "1.2.2")]);
    }

    #[test]
    fn test_npm_lock() {
        let contents = r#"
{
  "name": "subsea-layout",
  "version": "0.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "subsea-layout",
      "version": "0.0.0",
      "dependencies": {
        "@eslint": "^2.1.2"
      }
    },
    "node_modules/@eslint/eslintrc": {
      "version": "2.1.2",
       "resolved": "https://registry.npmjs.org/@eslint/eslintrc/-/eslintrc-2.1.2.tgz"
    }
  }
}
"#;

        let packages = parse_lock("package-lock.json", contents).unwrap();
        assert_eq!(&packages, &[Package::new("@eslint/eslintrc", "2.1.2")]);
    }
}
